# 设计模式
## 设计模式作用
- 写出优雅的代码
- 更方便的维护项目
## 设计模式分类
总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
## 工厂模式
### 简单工厂模式（Simple Factory Pattern）
是指由一个工厂对象决定创建出哪一种产品类 的实例，但它不属于 GOF，23 种设计模式。  

简单工厂适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。  

缺点： 工厂类的职责相对过重，不易于扩展过于复杂的产品结构。  

### 工厂方法模式(Factory Method Pattern)
是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行，在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节。  

工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个产品的创建逻辑有区别的话，工厂的职责会变得越来越多，有点像万能工厂，并不便于维护。根据单一职责原则我们将职能继续拆分，专人干专事。什么产品就由什么工厂来创建。  

### 抽象工厂模式（Abstract Factory Pattern）
是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。  

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

## 单例模式（Singleton Pattern）
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 饿汉式单例
在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线程还没出现以前就实例化了，不可能存在访问安全问题。  
优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。  
缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存。  

### 懒汉式单例
被外部类调用的时候内部类才会加载，有线程安全性问题，用了synchronized，性能会有所下降。

### 懒汉式内部类单例
这种形式兼顾饿汉式的内存浪费，也兼顾synchronized性能问题。  
内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题。  


### 线程单例
线程单例不能保证其创建的对象是全局唯一，但是能保证在单个线程中是唯一的，天生的线程安全。  


## 原型模式（Prototype Pattern）
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。  
使用场景：  
1、资源优化场景  
2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。  
3、性能和安全要求的场景。  
4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。   
5、一个对象多个修改者的场景。  
6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。  
7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。


## 代理模式（Proxy Pattern）
为其他对象提供一种代理以控制对这个对象的访问。  
主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。  

### JDK Proxy
生成对象的步骤：  
1、拿到被代理对象的引用，并且获取到它的所有的接口，反射获取。   
2、JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口。  
3、动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）。   
4、编译新生成的 Java 代码.class。   
5、再重新加载到 JVM 中运行。

### CGLib
CGLIB（Code Generator Library）是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。  

### CGLib 和 JDK 动态代理对比
 1.JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。   
 2.JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。   
 3.JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高。  
 
 ## 策略模式（Strategy Pattern）
 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。  
 使用场景：   
 - 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。  
 - 一个系统需要动态地在几种算法中选择一种。  
 - 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。  
 

## 模板模式（Template Pattern）
一个抽象类公开定义了执行它的方法的方式/模板，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。  
使用场景：  
- 有多个子类共有的方法，且逻辑相同。  
- 重要的、复杂的方法，可以考虑作为模板方法。

优点： 
- 封装不变部分，扩展可变部分。  
- 提取公共代码，便于维护。   
- 行为由父类控制，子类实现。

缺点：  
每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大  
## 适配器模式（Adapter Pattern）
将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  
主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。  
优点：   
- 可以让任何两个没有关联的类一起运行。   
- 提高了类的复用。   
- 增加了类的透明度。   
- 灵活性好。

缺点：   
- 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。   
-  由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。  

 ## 装饰者模式（Decorator Pattern）
 允许向一个现有的对象添加新的功能，同时又不改变其结构。  
 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 
 
 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。  
 
 缺点：多层装饰比较复杂。  
 
 ## 观察者模式（Observer Pattern）
 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。  
 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。  
 优点：   
 - 观察者和被观察者是抽象耦合的。   
 - 建立一套触发机制。    
  
 
缺点：   
- 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。   
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。  
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化  

